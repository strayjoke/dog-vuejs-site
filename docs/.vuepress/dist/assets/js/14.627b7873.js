(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{325:function(t,e,a){"use strict";a.r(e);var r=a(33),s=Object(r.a)({},(function(){var t=this,e=t.$createElement,a=t._self._c||e;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"状态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#状态"}},[t._v("#")]),t._v(" 状态")]),t._v(" "),a("h3",{attrs:{id:"getter"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#getter"}},[t._v("#")]),t._v(" Getter")]),t._v(" "),a("ul",[a("li",[t._v("store 中的 state 中派生出一些状态")]),t._v(" "),a("li",[t._v("就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。")])]),t._v(" "),a("h3",{attrs:{id:"辅助函数"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#辅助函数"}},[t._v("#")]),t._v(" 辅助函数")]),t._v(" "),a("ul",[a("li",[t._v("总结一句话：全局映射到组件")])]),t._v(" "),a("h3",{attrs:{id:"module-和命名空间"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#module-和命名空间"}},[t._v("#")]),t._v(" Module 和命名空间")]),t._v(" "),a("ul",[a("li",[t._v("模块拥有自己的 state、mutation、action、getter，也可以有嵌套模块。")]),t._v(" "),a("li",[t._v("模块内部的 action、mutation 和 getter 是注册在全局命名空间的。通过添加 namespaced: true 的方式使其成为带命名空间的模块。")])]),t._v(" "),a("h3",{attrs:{id:"表单处理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#表单处理"}},[t._v("#")]),t._v(" 表单处理")]),t._v(" "),a("ul",[a("li",[t._v("在属于 Vuex 的 state 上使用 v-model 会比较棘手，建议使用带有 setter 的双向绑定计算属性")])])])}),[],!1,null,null,null);e.default=s.exports}}]);