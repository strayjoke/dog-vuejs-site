(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{326:function(t,a,e){"use strict";e.r(a);var r=e(33),s=Object(r.a)({},(function(){var t=this,a=t.$createElement,e=t._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"响应式原理"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#响应式原理"}},[t._v("#")]),t._v(" 响应式原理")]),t._v(" "),e("p",[e("img",{attrs:{src:"/images/active-data.png",alt:"响应式图解"}})]),t._v(" "),e("h3",{attrs:{id:"发布订阅模式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#发布订阅模式"}},[t._v("#")]),t._v(" 发布订阅模式")]),t._v(" "),e("p",[t._v("每个组件实例都对应一个 watcher 实例，它会在组件渲染的过程中把“接触”过的数据 property 记录为依赖。之后当依赖项的 setter 触发时，会通知 watcher，从而使它关联的组件重新渲染。")]),t._v(" "),e("h3",{attrs:{id:"异步更新队列"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步更新队列"}},[t._v("#")]),t._v(" 异步更新队列")]),t._v(" "),e("p",[t._v("Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。如果同一个 watcher 被多次触发，只会被推入到队列中一次。")])])}),[],!1,null,null,null);a.default=s.exports}}]);